{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "deep-gray",
    "glyph" : "chart-line"
  },
  "name" : "Taostats widget V6",
  "script" : "\/\/ Version 1.7 (Single API Call)\n\/\/ Author: YDC\n\n\/\/ ============================\n\/\/ Configuration and Constants\n\/\/ ============================\n\n\/\/ API Configuration\nconst API_CONFIG = {\n    baseUrl: \"https:\/\/api.taostats.io\/api\/v1\/\",\n    headers: {\n        \"Authorization\": \"9GZO9hNqzC1Aaqx7VEOmC8WcLQnCn3TSzp2Exil4EVqIo79b7LxCZF4yt8bitJtR\",\n        \"Accept\": \"application\/json\",\n    }\n};\n\n\/\/ Constants\nconst RAO = 10 ** -9; \/\/ Scaling factor for converting RAO to TAO\n\nconst ENV = {\n    colors: {\n        bg: new Color('#0E0E0E'), \/\/ Background color\n        neuron_bg: new Color('#1b1b1b'), \/\/For neurons stack element bg\n        neuron_err_bg: new Color('#4e0000'), \/\/For neurons with error stack element bg\n        err: new Color(\"#eb0000\"), \/\/For errors text\n        gold: new Color('#FDE047'), \/\/For Stake\n        white: Color.white(), \/\/ For Daily Reward\n        cyan_green: new Color('#00c2a6'), \/\/For UIDs\n        cyan_green_sim: new Color('#00c2b6'), \/\/For TAO price\n        orange_pearl: new Color('#e88148'), \/\/For TAO\n        gray: Color.gray(), \/\/ For secondary info\n    },\n    format_big_numbers: true, \/\/Format to thousends (K), millions (M), billions (B). Default true\n    tao_scale_factor: 5, \/\/Numbers after .(dot)\n    usd_scale_factor: 2, \/\/Numbers after .(dot)\n    idleTimeMilis: 900000, \/\/ Minimum widget reftesh idle interval in millis\n\n    \/\/BE CAREFUL. Space sensitive values. Refer to widget size. Changing may cause visual collisions\n    line_spacing: 4, \/\/Vertical space between lines in medium size widget. Default 4\n    part_spacing: 7, \/\/Vertical space between parts of any size widget. Default 7\n    transverce_spacing: 15, \/\/Horizontal space between total and price stacks of medium and large size widget. Default 15\n    neurons_per_line_count: 2, \/\/Count of neurons per line in large size widget\n};\n\n\/\/ ============================\n\/\/ Main Execution\n\/\/ ============================\n\nlet widgetParameters\nif (config.runsInApp) {\n    widgetParameters = \"0,0\"; \/\/ Required first subnet_id and at least one uid. Defaults for debug in app\n    config.widgetFamily = \"medium\"; \/\/ PREVIEW OF WIDGET IN APP (SMALL, MEDIUM or LARGE)\n} else {\n    widgetParameters = args.widgetParameter;\n}\n\ntry {\n        \/\/ Get UIDs from widget parameters\n        const widgetInput = widgetParameters.split(',').map(uid => uid.trim());\n        const subnetId = widgetInput[0];\n        widgetInput.shift();\n        \n        \/\/ Fetch price\n        const price = await fetchPrice();\n\n        \/\/ Fetch all neuron data\n        const neurons = await fetchNeuronsByUids(subnetId, widgetInput, price);\n        \n        \/\/ Create the widget\n        const widget = await createWidget(neurons, price);\n\n        if (!config.runsInWidget) {\n            \/\/ Show Widget Preview\n            switch (config.widgetFamily) {\n                case \"small\": await widget.presentSmall(); break\n                case \"medium\": await widget.presentMedium(); break\n                case \"large\": await widget.presentLarge(); break\n            }\n        } else {\n            \/\/ Tell the system to show the widget.\n            Script.setWidget(widget)\n            Script.complete()\n        }\n    } catch (error) {\n        console.error(error);\n}\n\n\/\/ ============================\n\/\/ Data Fetching Functions\n\/\/ ============================\n\nasync function fetchNeuronsByUids(subnetId, uids, price) {\n    try {\n        const allNeurons = await fetchAllNeurons(subnetId);\n\n        return uids.map(uid => {\n            \/\/ Find the neuron by UID in the pre-fetched neuron list\n            let neuron = allNeurons.find(neuron => neuron.neuron_id === parseInt(uid));\n\n            if (typeof neuron !== 'undefined') {\n                const dailyTAO = (parseFloat(neuron.daily_reward) * RAO).toFixed(ENV.tao_scale_factor);\n                const dailyUSD = (parseFloat(neuron.daily_reward) * RAO * parseFloat(price)).toFixed(2);\n\n                const stakeTAO = (parseFloat(neuron.stake) * RAO).toFixed(ENV.tao_scale_factor);\n                const stakeUSD = (parseFloat(neuron.stake) * RAO * parseFloat(price)).toFixed(2);\n                \n                return { uid, dailyTAO, dailyUSD, stakeTAO, stakeUSD };\n            } else {\n                return { uid, error: `Neuron ${uid} not found` };\n            }\n        });\n    } catch (error) {\n        console.error(\"Failed to process neurons data:\", error);\n        return { uid: 0, error: \"Failed to process neurons data\" };\n    }\n}\n\nasync function fetchAllNeurons(subnetId) {\n    try {\n        const url = `${API_CONFIG.baseUrl}metagraph?subnet_id=${subnetId}`;\n        let request = new Request(url);\n        request.headers = API_CONFIG.headers;\n        \n        let response = await request.loadJSON();\n\n        \/\/ Check if response.items exists and is an array\n        if (!response || !Array.isArray(response.items)) {\n            throw new Error('Invalid API response: \"items\" is missing or not an array.');\n        }\n\n        return response.items; \/\/ Return the full list of neurons\n    } catch (error) {\n        console.error('Failed fetching neurons:', error);\n        return []; \/\/ Return an empty array in case of an error\n    }\n}\n\nasync function fetchPrice() {\n    try {\n        const url = `${API_CONFIG.baseUrl}price?asset=tao&limit=1`;\n        let request = new Request(url);\n        request.headers = API_CONFIG.headers;\n        \n        let response = await request.loadJSON();\n\n        if (!response || !Array.isArray(response.prices)) {\n            throw new Error('Invalid API response: \"prices\" is missing or not an array.');\n        }\n\n        return response.prices[0].price;\n    } catch (error) {\n        console.error('Failed fetching TAO price:', error);\n        return 0; \/\/ Return 0 in case of an error, to avoid breaking calculations\n    }\n}\n\n\/\/ ============================\n\/\/ Widget Creation Function\n\/\/ ============================\n\nasync function createWidget(neurons, price) {\n    const widget = new ListWidget();\n    widget.backgroundColor = ENV.colors.bg;\n\n    let totalStakeTAO = 0;\n    let totalStakeUSD = 0;\n    let totalDailyTAO = 0;\n    let totalDailyUSD = 0;\n\n    neurons.forEach(neuron => {\n        if (!neuron.error) {\n            \/\/ Update total stake and daily rewards\n            totalStakeTAO += parseFloat(neuron.stakeTAO);\n            totalStakeUSD += parseFloat(neuron.stakeUSD);\n            totalDailyTAO += parseFloat(neuron.dailyTAO);\n            totalDailyUSD += parseFloat(neuron.dailyUSD);\n        }\n    });\n\n    const frame = widget.addStack();\n    frame.spacing = ENV.part_spacing;\n    frame.layoutVertically();\n\n    switch (config.widgetFamily) {\n        case \"small\": {\n            addTotalStack(frame, totalStakeTAO, totalStakeUSD, \"Total Stake\", ENV.colors.gold, 13, 21);\n            addTotalStack(frame, totalDailyTAO, totalDailyUSD, \"Total Daily\", ENV.colors.white, 13, 21);\n            \n            const bottomStack = frame.addStack();\n            bottomStack.layoutVertically();\n\n            const uidStack = bottomStack.addStack();\n            uidStack.spacing = 3;\n            {\n                uidStack.addSpacer();\n\n                addSemiboldText(uidStack, \"UIDs: \", 11, ENV.colors.gray);\n\n                neurons.forEach(neuron => {\n                    if(!neuron.error){\n                        addSemiboldText(uidStack, `${neuron.uid}`, 11, ENV.colors.cyan_green);\n                    } else {\n                        addSemiboldText(uidStack, `${neuron.uid}`, 11, ENV.colors.err);\n                    }\n                });\n                \n                uidStack.addSpacer();\n            }\n\n            \/\/ Last Updated at the bottom of the widget\n            const timeStack = bottomStack.addStack();\n            {\n                timeStack.addSpacer();\n\n                addSystemText(timeStack, \"Sync: \", 11, ENV.colors.gray);\n                \n                let nowUpdatedDate = timeStack.addDate(new Date());\n                nowUpdatedDate.textColor = ENV.colors.gray;\n                nowUpdatedDate.font = Font.systemFont(11);\n                nowUpdatedDate.applyTimeStyle();\n                \n                timeStack.addSpacer();\n            }\n        }\n            break;\n        case \"medium\": {\n            const neuronsPanel = frame.addStack();\n            {\n                const uidStack = neuronsPanel.addStack();\n                uidStack.spacing = ENV.line_spacing;\n                uidStack.layoutVertically();\n                addSemiboldText(uidStack, \"SN16\", 13, ENV.colors.cyan_green);\n\n                neuronsPanel.addSpacer(); \/\/ Flexible spacer\n\n                const stakeStack = neuronsPanel.addStack();\n                stakeStack.spacing = ENV.line_spacing;\n                stakeStack.layoutVertically();\n                addSemiboldText(stakeStack, \"Stake\", 13, ENV.colors.gold);\n                \n                neuronsPanel.addSpacer(); \/\/ Flexible spacer\n\n                const dailyStack = neuronsPanel.addStack();\n                dailyStack.spacing = ENV.line_spacing;\n                dailyStack.layoutVertically();\n                addSemiboldText(dailyStack, \"Daily\", 13, ENV.colors.white);  \n\n                neurons.forEach(neuron => {\n                    if (!neuron.error) {\n                        addNeuronDataRow(uidStack, stakeStack, dailyStack, neuron);\n                    } else {\n                        addSemiboldText(frame, `UID ${neuron.uid}: ${neuron.error}`, 11, ENV.colors.err);\n                    }\n                });\n            }\n\n            const bottomPanel = frame.addStack();\n            bottomPanel.spacing = ENV.transverce_spacing;\n            { \n                addGeneralStack(bottomPanel, price, ENV.colors.cyan_green_sim, 9, 21);\n\n                addTotalStack(bottomPanel, totalStakeTAO, totalStakeUSD, \"Total Stake\", ENV.colors.gold, 9, 21);\n                addTotalStack(bottomPanel, totalDailyTAO, totalDailyUSD, \"Total Daily\", ENV.colors.white, 9, 21);\n            }\n        }\n            break;\n        case \"large\": {\n            const headersPanel = frame.addStack();\n            headersPanel.spacing = ENV.transverce_spacing;\n            {  \n                addTotalStack(headersPanel, totalStakeTAO, totalStakeUSD, \"Total Stake\", ENV.colors.gold, 9, 21);\n                addTotalStack(headersPanel, totalDailyTAO, totalDailyUSD, \"Total Daily\", ENV.colors.white, 9, 21);\n                \n                addGeneralStack(headersPanel, price, ENV.colors.cyan_green_sim, 9, 21);\n            }\n\n            const neuronsPanel = frame.addStack();\n            neuronsPanel.spacing = ENV.part_spacing;\n            neuronsPanel.layoutVertically();\n            {\n                let neuronsMatix = listToMatrix(neurons, ENV.neurons_per_line_count);\n\n                for (i = 0; i < neuronsMatix.length; i++) {\n                    let neuronsLine = neuronsPanel.addStack();\n                    neuronsLine.spacing = ENV.part_spacing;\n\n                    for (j = 0; j < neuronsMatix[i].length; j++) {\n                        addNeuronStack(neuronsLine, neuronsMatix[i][j]);\n                    }\n                }     \n            }\n\n            frame.addSpacer();\n        }\n            break;\n    }\n\n    widget.refreshAfterDate = new Date(Date.now() + ENV.idleTimeMilis);\n    return widget;\n}\n\nfunction addTotalStack(frame, totalTAO, totalUSD, title, color, titleSize, valueSize) {\n    const col = frame.addStack();\n    col.layoutVertically();\n\n    addSemiboldText(col, title, titleSize, ENV.colors.gray);\n    \n    addSystemText(col, `$${formatNumber(totalUSD, ENV.usd_scale_factor)}`, valueSize, color);\n    addSystemText(col, `τ${formatNumber(totalTAO, ENV.tao_scale_factor)}`, valueSize \/ 1.9, ENV.colors.orange_pearl);\n}\n\nfunction addGeneralStack(frame, price, color, titleSize, valueSize){\n    const col = frame.addStack();\n    col.layoutVertically();\n\n    addSemiboldText(col, \"TAO Price\", titleSize, ENV.colors.gray);\n    addSemiboldText(col, `$${formatNumber(parseFloat(price), ENV.usd_scale_factor)}`, valueSize, color);\n\n    \/\/ Last Updated at the bottom of the widget\n    let nowUpdatedDate = col.addDate(new Date());\n    nowUpdatedDate.textColor = ENV.colors.gray;\n    nowUpdatedDate.font = Font.semiboldSystemFont(valueSize \/ 1.9);\n    nowUpdatedDate.applyRelativeStyle();\n}\n\nfunction addNeuronDataRow(uidStack, stakeStack, dailyStack, neuron) {\n    addSemiboldText(uidStack, `UID ${neuron.uid}`, 11, ENV.colors.cyan_green);\n    addSemiboldText(stakeStack, `τ${formatNumber(neuron.stakeTAO, ENV.tao_scale_factor)} \/ $${formatNumber(neuron.stakeUSD, ENV.usd_scale_factor)}`, 11, ENV.colors.gold);\n    addSemiboldText(dailyStack, `τ${formatNumber(neuron.dailyTAO, ENV.tao_scale_factor)} \/ $${formatNumber(neuron.dailyUSD, ENV.usd_scale_factor)}`, 11, ENV.colors.white);\n}\n\nfunction addUidStack(frame, tPrice, cPrice, size, color) {\n    const stack = frame.addStack();\n    stack.setPadding(0, 7, 0, 7);\n    \n    let tText = stack.addText(`τ${formatNumber(tPrice, ENV.tao_scale_factor, 2)}`);\n    tText.font = Font.semiboldSystemFont(size);\n    tText.textColor = color;\n\n    stack.addSpacer();\n\n    let dText = stack.addText(\"\/\");\n    dText.font = Font.semiboldSystemFont(size);\n    dText.textColor = color;\n\n    stack.addSpacer();\n\n    let cText = stack.addText(`$${formatNumber(cPrice, ENV.usd_scale_factor)}`);\n    cText.font = Font.semiboldSystemFont(size);\n    cText.textColor = color;\n}\n\nfunction addNeuronStack(neuronsPanel, neuron) {\n    let neuronStack = neuronsPanel.addStack();\n    neuronStack.size = new Size(300 \/ ENV.neurons_per_line_count, 60);\n    neuronStack.backgroundColor = neuron.error ? ENV.colors.neuron_err_bg : ENV.colors.neuron_bg;\n    neuronStack.cornerRadius = 15;\n    neuronStack.spacing = ENV.line_spacing;\n    neuronStack.layoutVertically();\n    {\n        addCenterText(neuronStack, `UID ${neuron.uid}`, 26 \/ ENV.neurons_per_line_count, ENV.colors.cyan_green);\n\n        if(!neuron.error) {\n            addUidStack(neuronStack, neuron.stakeTAO, neuron.stakeUSD, 22 \/ ENV.neurons_per_line_count, ENV.colors.gold);\n            addUidStack(neuronStack, neuron.dailyTAO, neuron.dailyUSD, 22 \/ ENV.neurons_per_line_count, ENV.colors.white);\n        } else {\n            addCenterText(neuronStack, `${neuron.error}`, 22 \/ ENV.neurons_per_line_count, ENV.colors.err);\n        }\n    }\n}\n\nfunction addCenterText(frame, text, size, color) {\n    let stack = frame.addStack();\n    {\n        stack.addSpacer();\n        addSemiboldText(stack, text, size, color);\n        stack.addSpacer();\n    }\n}\n\nfunction addSemiboldText(frame, text, size, color) {\n    let stackText = frame.addText(text);\n    stackText.font = Font.semiboldSystemFont(size);\n    stackText.textColor = color;\n}\n\nfunction addSystemText(frame, text, size, color) {\n    let stackText = frame.addText(text);\n    stackText.font = Font.systemFont(size);\n    stackText.textColor = color;\n}\n\n\/\/ ============================\n\/\/ Helper Functions\n\/\/ ============================\n\nfunction listToMatrix(list, elementsPerSubArray) {\n    var matrix = [], i, k;\n\n    for (i = 0, k = -1; i < list.length; i++) {\n        if (i % elementsPerSubArray === 0) {\n            k++;\n            matrix[k] = [];\n        }\n\n        matrix[k].push(list[i]);\n    }\n\n    return matrix;\n}\n\nfunction formatNumber(num, scale, minScale = scale) {\n    if(ENV.format_big_numbers){\n        if (num >= 1e9) {\n            return (num \/ 1e9).toFixed(minScale) + 'B'; \/\/ Billions\n        } else if (num >= 1e6) {\n            return (num \/ 1e6).toFixed(minScale) + 'M'; \/\/ Millions\n        } else if (num >= 1e4) {\n            return (num \/ 1e3).toFixed(minScale) + 'K'; \/\/ Thousands\n        } else {\n            return parseFloat(num).toFixed(scale); \/\/ Less than 10000\n        }\n    }\n    return parseFloat(num).toFixed(scale);\n}",
  "share_sheet_inputs" : [

  ]
}