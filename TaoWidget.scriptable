// Version 1.3 - Refactored

// ============================
// Configuration
// ============================

const API_CONFIG = {
  baseUrl: 'https://widget.secondbuy.site/api',
  getTaoPriceUrl: 'https://api.binance.com/api/v3/ticker/price?symbol=TAOUSDT'
};

const RAO = 10 ** -9;

const ENV = {
  colors: {
    bg: new Color('#0E0E0E'),
    err: new Color('#ad4904'),
    gold: new Color('#FDE047'),
    white: Color.white(),
    cyan_green: new Color('#00c2a6'),
    cyan_green_sim: new Color('#00c2b6'),
    orange_pearl: new Color('#e88148'),
    gray: Color.gray(),
    forEvenRow: new Color('#74b9ff'),
    forNotEvenRow: new Color('#a29bfe'),
  },
  spacing: 4,
  part_spacing: 7,
  refreshInterval: 300000,
};

// ============================
// Main Execution
// ============================

const widgetParameters = config.runsInApp
  ? '138, 39, 1, 2, 3, 4, 5, 6, 7'
  : args.widgetParameter;

if (config.runsInApp) {
  config.widgetFamily = 'large';
}

try {
  const widgetInput = widgetParameters.split(',').map(uid => uid.trim());
  const prices = await fetchPrices();
  const neurons = await fetchNeuronsByUids(widgetInput, prices);
  neurons.sort((a, b) => parseInt(a.uid) - parseInt(b.uid));
  const totals = calculateTotals(neurons);
  const widget = createWidget(neurons, prices, totals);

  if (!config.runsInWidget) {
    const presentMethods = {
      small: () => widget.presentSmall(),
      medium: () => widget.presentMedium(),
      large: () => widget.presentLarge()
    };
    await presentMethods[config.widgetFamily]();
  } else {
    Script.setWidget(widget);
    Script.complete();
  }
} catch (error) {
  console.error(error);
}

// ============================
// Data Fetching
// ============================

async function fetchNeuronsByUids(uids, prices) {
  try {
    const allNeurons = await fetchAllNeurons();
    const { alphaToTao, taoToUsdt } = prices;

    return uids.map(uid => {
      const neuron = allNeurons.find(n => n.uid === parseInt(uid));
      if (!neuron) {
        return { uid, error: 'Neuron not found' };
      }

      const dailyAlphaToken = parseFloat(neuron.daily_reward) * RAO;
      const stakeAlphaToken = parseFloat(neuron.alpha_stake) * RAO;
      const dailyTao = dailyAlphaToken * alphaToTao;
      const stakeTao = stakeAlphaToken * alphaToTao;
      const dailyUSD = dailyTao * taoToUsdt;
      const stakeUSD = stakeTao * taoToUsdt;

      return { uid, dailyAlphaToken, stakeAlphaToken, dailyTao, stakeTao, dailyUSD, stakeUSD };
    });
  } catch (error) {
    console.error('Failed to fetch neurons:', error);
    return uids.map(uid => ({ uid, error: 'Failed to process neuron data.' }));
  }
}

function calculateTotals(neurons) {
  const initialTotals = {
    dailyTotalAlphaToken: 0,
    stakeTotalAlphaToken: 0,
    dailyTotalTao: 0,
    stakeTotalTao: 0,
    dailyTotalUSD: 0,
    stakeTotalUSD: 0
  };

  return neurons.reduce((acc, neuron) => {
    if (!neuron.error) {
      acc.dailyTotalAlphaToken += neuron.dailyAlphaToken;
      acc.stakeTotalAlphaToken += neuron.stakeAlphaToken;
      acc.dailyTotalTao += neuron.dailyTao;
      acc.stakeTotalTao += neuron.stakeTao;
      acc.dailyTotalUSD += neuron.dailyUSD;
      acc.stakeTotalUSD += neuron.stakeUSD;
    }
    return acc;
  }, initialTotals);
}

async function fetchAllNeurons() {
  try {
    const url = `${API_CONFIG.baseUrl}/metagraph/latest/v1?netuid=16`;
    const response = await new Request(url).loadJSON();

    if (!response || !Array.isArray(response.data)) {
      throw new Error('Invalid API response');
    }

    return response.data;
  } catch (error) {
    console.error('Error fetching neuron data:', error);
    return [];
  }
}

async function fetchPrice(url) {
  try {
    const response = await new Request(url).loadJSON();
    return response;
  } catch (error) {
    console.error(`Error fetching price from ${url}:`, error);
    return null;
  }
}

async function fetchPrices() {
  const prices = { alphaToTao: -1, taoToUsdt: -1 };

  const alphaResp = await fetchPrice(`${API_CONFIG.baseUrl}/dtao/pool/v1`);
  if (alphaResp && Array.isArray(alphaResp.data)) {
    prices.alphaToTao = alphaResp.data[0].price;
  }

  const taoResp = await fetchPrice(API_CONFIG.getTaoPriceUrl);
  if (taoResp && taoResp.price) {
    prices.taoToUsdt = taoResp.price;
  }

  return prices;
}

// ============================
// Widget Creation
// ============================

function createWidget(neurons, prices, totals) {
  const widget = new ListWidget();
  widget.backgroundColor = ENV.colors.bg;

  const frame = widget.addStack();
  frame.spacing = ENV.part_spacing;
  frame.layoutVertically();

  if (config.widgetFamily === 'small') {
    drawTotalStack(frame, totals);
    drawPrices(frame, prices);
    drawFooterForSmall(frame, neurons);
  } else {
    const neuronsPanel = frame.addStack();
    const tableStacks = drawTableForLarge(neuronsPanel);
    drawNeuronsStatForLarge(neurons, tableStacks);
    drawTotalStackToTable(tableStacks, totals);

    const bottomPanel = frame.addStack();
    bottomPanel.layoutVertically();
    bottomPanel.addSpacer(5);
    drawPrices(bottomPanel, prices, true);
    drawTimeUpdated(bottomPanel);
  }

  widget.refreshAfterDate = new Date(Date.now() + ENV.refreshInterval);
  return widget;
}

function drawTotalStack(frame, totals) {
  const rowStack = frame.addStack();
  rowStack.layoutHorizontally();

  const colTotalStake = rowStack.addStack();
  colTotalStake.layoutVertically();
  addText(colTotalStake, '∑ Stake', 18, ENV.colors.gray, true);
  addText(colTotalStake, `α${totals.stakeTotalAlphaToken.toFixed(2)}`, 14, ENV.colors.cyan_green_sim);
  addText(colTotalStake, `τ${totals.stakeTotalTao.toFixed(2)}`, 14, ENV.colors.orange_pearl);
  addText(colTotalStake, `$${totals.stakeTotalUSD.toFixed(2)}`, 14, ENV.colors.gold);

  rowStack.addSpacer();

  const colTotalDaily = rowStack.addStack();
  colTotalDaily.layoutVertically();
  addText(colTotalDaily, '∑ Daily', 13, ENV.colors.gray, true);
  addText(colTotalDaily, `α${totals.dailyTotalAlphaToken.toFixed(2)}`, 11, ENV.colors.cyan_green_sim);
  addText(colTotalDaily, `τ${totals.dailyTotalTao.toFixed(2)}`, 11, ENV.colors.orange_pearl);
  addText(colTotalDaily, `$${totals.dailyTotalUSD.toFixed(2)}`, 11, ENV.colors.gold);
}

function drawTotalStackToTable(stacks, totals) {
  const [col0, col1, col2] = stacks;
  addText(col0, '∑', 18, ENV.colors.cyan_green_sim, true);
  addText(col1, `α${totals.stakeTotalAlphaToken.toFixed(0)} | t${totals.stakeTotalTao.toFixed(2)} | $${totals.stakeTotalUSD.toFixed(2)}`, 14, ENV.colors.orange_pearl, true);
  addText(col2, `α${totals.dailyTotalAlphaToken.toFixed(0)} |t${totals.dailyTotalTao.toFixed(2)} | $${totals.dailyTotalUSD.toFixed(2)}`, 14, ENV.colors.gold, true);
}

function drawFooterForSmall(frame, neurons) {
  const bottomStack = frame.addStack();
  bottomStack.layoutVertically();

  const uidStack = bottomStack.addStack();
  uidStack.spacing = 3;
  uidStack.addSpacer();
  addText(uidStack, 'UIDs: ', 11, ENV.colors.gray, true);

  neurons.forEach(neuron => {
    const color = neuron.error ? ENV.colors.err : ENV.colors.cyan_green;
    addText(uidStack, `${neuron.uid}`, 11, color, true);
  });

  uidStack.addSpacer();
  drawTimeUpdated(bottomStack);
}

function drawTimeUpdated(stack) {
  const timeStack = stack.addStack();
  timeStack.addSpacer();
  addText(timeStack, 'Sync: ', 11, ENV.colors.gray);

  const date = timeStack.addDate(new Date());
  date.textColor = ENV.colors.gray;
  date.font = Font.systemFont(11);
  date.applyTimeStyle();
  timeStack.addSpacer();
}

function drawPrices(frame, prices, isLarge = false) {
  const rowStack = frame.addStack();
  rowStack.layoutHorizontally();
  const spacer = isLarge ? null : 5;

  const col1 = rowStack.addStack();
  col1.layoutVertically();
  addText(col1, '1τ = ', 11, ENV.colors.orange_pearl, true);

  rowStack.addSpacer(spacer);

  const col2 = rowStack.addStack();
  col2.layoutVertically();
  addText(col2, `α${(1 / prices.alphaToTao).toFixed(2)}`, 11, ENV.colors.cyan_green_sim, true);

  rowStack.addSpacer(spacer);

  const col3 = rowStack.addStack();
  col3.layoutVertically();
  addText(col3, `$${parseFloat(prices.taoToUsdt).toFixed(2)}`, 11, ENV.colors.gold, true);
}

function drawTableForLarge(frame) {
  const createColumn = (title, color) => {
    const stack = frame.addStack();
    stack.spacing = ENV.spacing;
    stack.layoutVertically();
    addText(stack, title, 13, color, true);
    return stack;
  };

  const uidStack = createColumn('UIDs', ENV.colors.cyan_green);
  frame.addSpacer();
  const stakeStack = createColumn('Stake', ENV.colors.gold);
  frame.addSpacer();
  const dailyStack = createColumn('Daily', ENV.colors.white);

  return [uidStack, stakeStack, dailyStack];
}

function drawNeuronsStatForLarge(neurons, stacks) {
  const [uidStack, stakeStack, dailyStack] = stacks;

  neurons.forEach((neuron, i) => {
    const color = i % 2 === 0 ? ENV.colors.forEvenRow : ENV.colors.forNotEvenRow;

    if (!neuron.error) {
      addText(uidStack, `${neuron.uid}`, 12, color, true);
      addText(stakeStack, `α${neuron.stakeAlphaToken.toFixed(1)} | t${neuron.stakeTao.toFixed(2)} | $${neuron.stakeUSD.toFixed(0)}`, 12, color, true);
      addText(dailyStack, `α${neuron.dailyAlphaToken.toFixed(2)} | $${neuron.dailyUSD.toFixed(2)}`, 12, color, true);
    } else {
      addText(uidStack, `UID ${neuron.uid}: ${neuron.error}`, 12, ENV.colors.err, true);
      addText(stakeStack, '-', 12, ENV.colors.err, true);
      addText(dailyStack, '-', 12, ENV.colors.err, true);
    }
  });
}

function addText(frame, text, size, color, isSemibold = false) {
  const textElement = frame.addText(text);
  textElement.font = isSemibold ? Font.semiboldSystemFont(size) : Font.systemFont(size);
  textElement.textColor = color;
}
