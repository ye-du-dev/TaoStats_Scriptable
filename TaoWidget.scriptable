{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "yellow",
    "glyph" : "magic"
  },
  "name" : "TaoWidget",
  "script" : "\/\/ Version 1.0\n\/\/ Author: YDC\n\n\/\/ ============================\n\/\/ Configuration and Constants\n\/\/ ============================\n\n\/\/ API Configuration\nconst API_CONFIG = {\n  baseUrl: 'https:\/\/secondbuy.site\/api'\n};\n\n\/\/ Constants\nconst RAO = 10 ** -9; \/\/ Scaling factor for converting RAO to TAO\n\nconst ENV = {\n  colors: {\n    bg: new Color('#0E0E0E'), \/\/ Background color\n    neuron_bg: new Color('#1b1b1b'),\n    neuron_err_bg: new Color('#4e0000'),\n    err: new Color('#ad4904'),\n    gold: new Color('#FDE047'), \/\/For Stake\n    white: Color.white(), \/\/ White for Daily Reward\n    cyan_green: new Color('#00c2a6'), \/\/For UIDs\n\n    cyan_green_sim: new Color('#00c2b6'), \/\/For TAO price\n    orange_pearl: new Color('#e88148'), \/\/For TAO\n    gray: Color.gray(), \/\/ For secondary info\n    forEvenRow: new Color('#74b9ff'),\n    forNotEvenRow: new Color('#a29bfe'),\n  },\n  spacing: 4,\n  part_spacing: 7,\n  transverce_spacing: 15,\n  refreshInterval: 300000,\n};\n\n\/\/ ============================\n\/\/ Main Execution\n\/\/ ============================\n\nlet widgetParameters;\nif (config.runsInApp) {\n  widgetParameters = '16 | 1, 2, 3, 4, 5, 6, 7'; \/\/ Required at least \"zero\". Defaults for debug in app\n  config.widgetFamily = 'large'; \/\/ PREVIEW OF WIDGET IN APP (SMALL, MEDIUM or LARGE)\n} else {\n  widgetParameters = args.widgetParameter;\n}\n\ntry {\n  \/\/ Split the string by `|` to separate netuid and uids\n  const [netuidString, uidString] = widgetParameters.split('|');\n\n  \/\/ Convert netuid to a number\n  const netuid = parseInt(netuidString.trim(), 10);\n\n  \/\/ Split uids by `,` and convert each to a number\n  const uids = uidString.split(',').map(uid => parseInt(uid.trim(), 10));\n\n  \/\/ Fetch price\n  const prices = await fetchPrices(netuid);\n\n  \/\/ Fetch all neuron data\n  const neurons = await fetchNeuronsByUids(uids, prices, netuid);\n  neurons.sort((a, b) => parseInt(a.uid) - parseInt(b.uid));\n\n  const totals = calculateTotals(neurons);\n\n  \/\/ Create the widget (pass netuid so it can be displayed later)\n  const widget = createWidget(neurons, prices, totals, netuid);\n\n  if (!config.runsInWidget) {\n    \/\/ Show Widget Preview\n    switch (config.widgetFamily) {\n      case 'small':\n        await widget.presentSmall();\n        break;\n      case 'medium':\n        await widget.presentMedium();\n        break;\n      case 'large':\n        await widget.presentLarge();\n        break;\n    }\n  } else {\n    \/\/ Tell the system to show the widget.\n    Script.setWidget(widget);\n    Script.complete();\n  }\n} catch (error) {\n  console.error(error);\n}\n\n\/\/ ============================\n\/\/ Data Fetching Functions\n\/\/ ============================\n\nasync function fetchNeuronsByUids(uids, prices, netuid) {\n  const allNeurons = await fetchAllNeurons(netuid);\n  try {\n    return uids.map(uid => {\n      \/\/ Find the neuron by UID in the pre-fetched neuron list\n      const neuron = allNeurons.find(neuron => neuron.uid === parseInt(uid));\n      const { alphaToTao, taoToUsdt } = prices;\n\n      if (typeof neuron !== 'undefined') {\n        const dailyAlphaToken = parseFloat(neuron.daily_reward) * RAO; \/\/ Daily reward in alpha tokens\n        const stakeAlphaToken = parseFloat(neuron.alpha_stake) * RAO;   \/\/ Total stake in alpha tokens\n\n        const dailyTao = dailyAlphaToken * alphaToTao;\n        const stakeTao = stakeAlphaToken * alphaToTao;\n\n        const dailyUSD = dailyTao * taoToUsdt;\n        const stakeUSD = stakeTao * taoToUsdt;\n\n        return { uid, dailyAlphaToken, stakeAlphaToken, dailyTao, stakeTao, dailyUSD, stakeUSD };\n      } else {\n        return { uid, error: 'Neuron not found' };\n      }\n    });\n  } catch (error) {\n    console.error('Failed to fetch neurons:', error);\n    return { uid: 0, error: 'Failed to process neuron data.' };\n  }\n}\n\nfunction calculateTotals(neurons) {\n  const initialTotals = {\n    dailyTotalAlphaToken: 0,\n    stakeTotalAlphaToken: 0,\n    dailyTotalTao: 0,\n    stakeTotalTao: 0,\n    dailyTotalUSD: 0,\n    stakeTotalUSD: 0\n  };\n\n  return neurons.reduce((acc, neuron) => {\n    if (!neuron.error) {\n      acc.dailyTotalAlphaToken += neuron.dailyAlphaToken;\n      acc.stakeTotalAlphaToken += neuron.stakeAlphaToken;\n      acc.dailyTotalTao       += neuron.dailyTao;\n      acc.stakeTotalTao       += neuron.stakeTao;\n      acc.dailyTotalUSD       += neuron.dailyUSD;\n      acc.stakeTotalUSD       += neuron.stakeUSD;\n    }\n    return acc;\n  }, initialTotals);\n}\n\nasync function fetchAllNeurons(netuid) {\n  const url = `${API_CONFIG.baseUrl}\/metagraph\/latest\/v1?netuid=${netuid}`;\n  try {\n    const response = await new Request(url).loadJSON();\n\n    if (!response || !Array.isArray(response.data)) {\n      throw new Error('Invalid API response: \"items\" is missing or not an array.');\n    }\n\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching neuron data:', error);\n    return [];\n  }\n}\n\nasync function fetchPrices(netuid) {\n  const prices = {\n    alphaToTao: -1,\n    taoToUsdt: -1,\n  };\n\n  \/\/ Price Alpha to TAO\n  let req = new Request(`${API_CONFIG.baseUrl}\/dtao\/pool\/v1?netuid=${netuid}`);\n  try {\n    const resp = await req.loadJSON();\n    if (Array.isArray(resp?.data)) {\n      prices.alphaToTao = resp.data[0].price;\n    }\n  } catch (e) {\n    console.error('Error when calling \/dtao\/pool\/v1 ', e);\n  }\n\n  \/\/ Price TAO to USDT\n  req = new Request(`${API_CONFIG.baseUrl}\/price\/latest\/v1?asset=tao`);\n  try {\n    const resp = await req.loadJSON();\n    if (Array.isArray(resp?.data)) {\n      prices.taoToUsdt = resp.data[0].price;\n    }\n  } catch (e) {\n    console.error('Error when calling \/price\/latest\/v1?asset=tao ', e);\n  }\n\n  return prices;\n}\n\n\/\/ ============================\n\/\/ Widget Creation Function\n\/\/ ============================\n\nfunction createWidget(neurons, prices, totals, netuid) {\n  const widget = new ListWidget();\n  widget.backgroundColor = ENV.colors.bg;\n\n  const frame = widget.addStack();\n  frame.spacing = ENV.part_spacing;\n  frame.layoutVertically();\n\n  switch (config.widgetFamily) {\n    case 'small':\n      drawTotalStack(frame, totals);\n      drawPrices(frame, prices);\n      drawFooterForSmall(frame, neurons, netuid);\n      break;\n    case 'large':\n    case 'medium':\n      const neuronsPanel = frame.addStack();\n      const tableStacks = drawTableForLarge(neuronsPanel);\n      drawNeuronsStatForLarge(neurons, tableStacks);\n      drawTotalStackToTable(tableStacks, totals);\n      const bottomPanel = frame.addStack();\n      bottomPanel.layoutVertically();\n      bottomPanel.addSpacer(5);\n      drawPrices(bottomPanel, prices, true);\n      drawTimeUpdated(bottomPanel, netuid);\n      break;\n  }\n\n  widget.refreshAfterDate = new Date(Date.now() + ENV.refreshInterval);\n  return widget;\n}\n\nfunction drawTotalStack(frame, totals) {\n  const rowStack = frame.addStack();\n  rowStack.layoutHorizontally();\n\n  \/\/ Left column for Stake totals\n  const colTotalStake = rowStack.addStack();\n  colTotalStake.layoutVertically();\n  addSemiboldText(colTotalStake, '∑ Stake', 18, ENV.colors.gray);\n  addSystemText(colTotalStake, `α${totals.stakeTotalAlphaToken.toFixed(2)}`, 14, ENV.colors.cyan_green_sim);\n  addSystemText(colTotalStake, `τ${totals.stakeTotalTao.toFixed(2)}`, 14, ENV.colors.orange_pearl);\n  addSystemText(colTotalStake, `$${totals.stakeTotalUSD.toFixed(2)}`, 14, ENV.colors.gold);\n\n  rowStack.addSpacer();\n\n  \/\/ Right column for Daily totals\n  const colTotalDaily = rowStack.addStack();\n  colTotalDaily.layoutVertically();\n  addSemiboldText(colTotalDaily, '∑ Daily', 13, ENV.colors.gray);\n  addSystemText(colTotalDaily, `α${totals.dailyTotalAlphaToken.toFixed(2)}`, 11, ENV.colors.cyan_green_sim);\n  addSystemText(colTotalDaily, `τ${totals.dailyTotalTao.toFixed(2)}`, 11, ENV.colors.orange_pearl);\n  addSystemText(colTotalDaily, `$${totals.dailyTotalUSD.toFixed(2)}`, 11, ENV.colors.gold);\n}\n\nfunction drawTotalStackToTable(stacks, totals) {\n  const [col0, col1, col2] = stacks;\n  addSemiboldText(col0, `∑`, 18, ENV.colors.cyan_green_sim);\n  addSemiboldText(col1, `α${totals.stakeTotalAlphaToken.toFixed(0)}  | τ${totals.stakeTotalTao.toFixed(2)} | $${totals.stakeTotalUSD.toFixed(2)}`, 14, ENV.colors.orange_pearl);\n  addSemiboldText(col2, `α${totals.dailyTotalAlphaToken.toFixed(0)} | τ${totals.dailyTotalTao.toFixed(2)} | $${totals.dailyTotalUSD.toFixed(2)}`, 14, ENV.colors.gold);\n}\n\nfunction drawFooterForSmall(frame, neurons, netuid) {\n  const bottomStack = frame.addStack();\n  bottomStack.layoutVertically();\n\n  const uidStack = bottomStack.addStack();\n  uidStack.spacing = 3;\n  {\n    uidStack.addSpacer();\n    addSemiboldText(uidStack, 'UIDs: ', 11, ENV.colors.gray);\n\n    neurons.forEach(neuron => {\n      if (!neuron.error) {\n        addSemiboldText(uidStack, `${neuron.uid}`, 11, ENV.colors.cyan_green);\n      } else {\n        addSemiboldText(uidStack, `${neuron.uid}`, 11, ENV.colors.err);\n      }\n    });\n    uidStack.addSpacer();\n  }\n\n  drawTimeUpdated(bottomStack, netuid);\n}\n\nfunction drawTimeUpdated(stack, netuid) {\n  \/\/ Display NetUID to the left of the Sync info\n  const timeStack = stack.addStack();\n  timeStack.addSpacer();\n  \n  addSystemText(timeStack, `SN: ${netuid} | Sync: `, 11, ENV.colors.gray);\n\n  let nowUpdatedDate = timeStack.addDate(new Date());\n  nowUpdatedDate.textColor = ENV.colors.gray;\n  nowUpdatedDate.font = Font.systemFont(11);\n  nowUpdatedDate.applyTimeStyle();\n  \n  timeStack.addSpacer();\n}\n\nfunction drawPrices(frame, prices, isLarge = false) {\n  const rowStack = frame.addStack();\n  rowStack.layoutHorizontally();\n\n  const col1 = rowStack.addStack();\n  col1.layoutVertically();\n  addSemiboldText(col1, `1τ = `, 11, ENV.colors.orange_pearl);\n\n  if (isLarge) {\n    rowStack.addSpacer();\n  } else {\n    rowStack.addSpacer(5);\n  }\n\n  const col2 = rowStack.addStack();\n  col2.layoutVertically();\n  addSemiboldText(col2, `α${(1 \/ prices.alphaToTao).toFixed(2)}`, 11, ENV.colors.cyan_green_sim);\n\n  if (isLarge) {\n    rowStack.addSpacer();\n  } else {\n    rowStack.addSpacer(5);\n  }\n\n  const col3 = rowStack.addStack();\n  col3.layoutVertically();\n  addSemiboldText(col3, `$${parseFloat(prices.taoToUsdt).toFixed(2)}`, 11, ENV.colors.gold);\n}\n\nfunction drawTableForLarge(frame) {\n  const uidStack = frame.addStack();\n  uidStack.spacing = ENV.spacing;\n  uidStack.layoutVertically();\n  addSemiboldText(uidStack, 'UIDs', 13, ENV.colors.cyan_green);\n\n  frame.addSpacer();\n\n  const stakeStack = frame.addStack();\n  stakeStack.spacing = ENV.spacing;\n  stakeStack.layoutVertically();\n  addSemiboldText(stakeStack, 'Stake', 13, ENV.colors.gold);\n\n  frame.addSpacer();\n\n  const dailyStack = frame.addStack();\n  dailyStack.spacing = ENV.spacing;\n  dailyStack.layoutVertically();\n  addSemiboldText(dailyStack, 'Daily', 13, ENV.colors.white);\n\n  return [uidStack, stakeStack, dailyStack];\n}\n\nfunction drawNeuronsStatForLarge(neurons, stacks) {\n  const [uidStack, stakeStack, dailyStack] = stacks;\n\n  neurons.forEach((neuron, i) => {\n    const currentColor = i % 2 === 0 ? ENV.colors.forEvenRow : ENV.colors.forNotEvenRow;\n\n    if (!neuron.error) {\n      addSemiboldText(uidStack, `${neuron.uid}`, 12, currentColor);\n      addSemiboldText(stakeStack, `α${neuron.stakeAlphaToken.toFixed(1)} | τ${neuron.stakeTao.toFixed(2)} | $${neuron.stakeUSD.toFixed(0)}`, 12, currentColor);\n      addSemiboldText(dailyStack, `α${neuron.dailyAlphaToken.toFixed(2)} | $${neuron.dailyUSD.toFixed(2)}`, 12, currentColor);\n    } else {\n      addSemiboldText(frame, `UID ${neuron.uid}: ${neuron.error}`, 12, ENV.colors.err);\n    }\n  });\n}\n\nfunction addSemiboldText(frame, text, size, color) {\n  let stackText = frame.addText(text);\n  stackText.font = Font.semiboldSystemFont(size);\n  stackText.textColor = color;\n}\n\nfunction addSystemText(frame, text, size, color) {\n  let stackText = frame.addText(text);\n  stackText.font = Font.systemFont(size);\n  stackText.textColor = color;\n}",
  "share_sheet_inputs" : [

  ]
}
