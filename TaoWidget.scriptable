// Version 1.4 - Dynamic Config

// ============================
// Configuration
// ============================

const CONFIG_URL = 'https://raw.githubusercontent.com/TAO-Radar/Scriptable-Widget/refs/heads/main/config.json';

const RAO = 10 ** -9;

const ENV = {
  colors: {
    bg: new Color('#0E0E0E'),
    err: new Color('#ad4904'),
    gold: new Color('#FDE047'),
    white: Color.white(),
    cyan_green: new Color('#00c2a6'),
    cyan_green_sim: new Color('#00c2b6'),
    orange_pearl: new Color('#e88148'),
    gray: Color.gray(),
    forEvenRow: new Color('#74b9ff'),
    forNotEvenRow: new Color('#a29bfe'),
  },
  spacing: 4,
  part_spacing: 7,
  refreshInterval: 300000,
};

// ============================
// Main Execution
// ============================

// Fetch API config dynamically
let API_CONFIG;
try {
  API_CONFIG = await fetchApiConfig();
} catch (error) {
  console.error('Failed to fetch API config:', error);
  // Fallback to default config if remote fetch fails
  API_CONFIG = {
    baseUrl: 'https://widget.secondbuy.site/api',
    getTaoPriceUrl: 'https://api.binance.com/api/v3/ticker/price?symbol=TAOUSDT'
  };
}

if (config.runsInApp) {
  // Show welcome message in app
  const widget = createWelcomeWidget();
  config.widgetFamily = 'large';
  await widget.presentLarge();
  Script.complete();
} else {
  // Running as widget
  const settingsId = args.widgetParameter;
  
  if (!settingsId) {
    // No settings provided - show error
    const widget = createErrorWidget('No settings ID provided. Please configure the widget with a settings ID.');
    Script.setWidget(widget);
    Script.complete();
  } else {
    try {
      const settings = await fetchSettings(settingsId);
      const prices = await fetchPrices();
      const neurons = await fetchNeuronsByAddresses(settings, prices);
      neurons.sort((a, b) => parseInt(a.uid) - parseInt(b.uid));
      const totals = calculateTotals(neurons);
      const widget = createWidget(neurons, prices, totals);
      Script.setWidget(widget);
      Script.complete();
    } catch (error) {
      console.error(error);
      const errorWidget = createErrorWidget(`Error: ${error.message || 'Failed to load widget data'}`);
      Script.setWidget(errorWidget);
      Script.complete();
    }
  }
}

// ============================
// Data Fetching
// ============================

async function fetchApiConfig() {
  try {
    const request = new Request(CONFIG_URL);
    const response = await request.loadJSON();
    
    if (!response || !response.baseUrl || !response.getTaoPriceUrl) {
      throw new Error('Invalid config response');
    }
    
    return {
      baseUrl: response.baseUrl,
      getTaoPriceUrl: response.getTaoPriceUrl
    };
  } catch (error) {
    console.error('Error fetching API config:', error);
    throw error;
  }
}

async function fetchSettings(settingId) {
  try {
    const url = `${API_CONFIG.baseUrl}/settings/${settingId}`;
    const request = new Request(url);
    
    // Load response to check status code
    const httpResponse = await request.load();
    const statusCode = request.response.statusCode;
    
    if (statusCode === 404) {
      throw new Error('Settings not found');
    }
    
    if (statusCode !== 200) {
      throw new Error(`Failed to fetch settings (status: ${statusCode})`);
    }
    
    // Parse JSON from response data
    const response = JSON.parse(httpResponse.toRawString());
    
    if (!response || !response.addresses || !Array.isArray(response.addresses) || !response.netuid) {
      throw new Error('Invalid settings response');
    }
    
    return {
      addresses: response.addresses,
      netuid: response.netuid
    };
  } catch (error) {
    console.error('Error fetching settings:', error);
    
    // Re-throw if it's already our custom error
    if (error.message === 'Settings not found') {
      throw error;
    }
    
    // Check error message for 404
    if (error.message && (error.message.includes('404') || error.message.includes('Not Found'))) {
      throw new Error('Settings not found');
    }
    
    throw error;
  }
}

async function fetchNeuronsByAddresses(settings, prices) {
  try {
    const allNeurons = await fetchAllNeurons(settings);
    
    if (allNeurons.length === 0) {
      return [{ uid: 0, error: 'No neurons found for the provided addresses.' }];
    }

    const { alphaToTao, taoToUsdt } = prices;

    return allNeurons.map(neuron => {
      const dailyAlphaToken = parseFloat(neuron.daily_reward) * RAO;
      const stakeAlphaToken = parseFloat(neuron.alpha_stake) * RAO;
      const dailyTao = dailyAlphaToken * alphaToTao;
      const stakeTao = stakeAlphaToken * alphaToTao;
      const dailyUSD = dailyTao * taoToUsdt;
      const stakeUSD = stakeTao * taoToUsdt;

      return {
        uid: neuron.uid,
        dailyAlphaToken,
        stakeAlphaToken,
        dailyTao,
        stakeTao,
        dailyUSD,
        stakeUSD
      };
    });
  } catch (error) {
    console.error('Failed to fetch neurons:', error);
    return [{ uid: 0, error: 'Failed to process neuron data.' }];
  }
}

function calculateTotals(neurons) {
  const initialTotals = {
    dailyTotalAlphaToken: 0,
    stakeTotalAlphaToken: 0,
    dailyTotalTao: 0,
    stakeTotalTao: 0,
    dailyTotalUSD: 0,
    stakeTotalUSD: 0
  };

  return neurons.reduce((acc, neuron) => {
    if (!neuron.error) {
      acc.dailyTotalAlphaToken += neuron.dailyAlphaToken;
      acc.stakeTotalAlphaToken += neuron.stakeAlphaToken;
      acc.dailyTotalTao += neuron.dailyTao;
      acc.stakeTotalTao += neuron.stakeTao;
      acc.dailyTotalUSD += neuron.dailyUSD;
      acc.stakeTotalUSD += neuron.stakeUSD;
    }
    return acc;
  }, initialTotals);
}

async function fetchAllNeurons(settings) {
  try {
    const allNeurons = [];
    const seenUids = new Set();

    // Fetch neurons for each address and combine results
    for (const address of settings.addresses) {
      try {
        const url = `${API_CONFIG.baseUrl}/metagraph/latest/v1?netuid=${settings.netuid}&search=${encodeURIComponent(address)}&page=1`;
        const response = await new Request(url).loadJSON();

        if (response && Array.isArray(response.data)) {
          // Add neurons that haven't been seen yet (deduplicate by UID)
          response.data.forEach(neuron => {
            if (!seenUids.has(neuron.uid)) {
              seenUids.add(neuron.uid);
              allNeurons.push(neuron);
            }
          });
        }
      } catch (error) {
        console.error(`Error fetching neurons for address ${address}:`, error);
      }
    }

    return allNeurons;
  } catch (error) {
    console.error('Error fetching neuron data:', error);
    return [];
  }
}

async function fetchPrice(url) {
  try {
    const response = await new Request(url).loadJSON();
    return response;
  } catch (error) {
    console.error(`Error fetching price from ${url}:`, error);
    return null;
  }
}

async function fetchPrices() {
  const prices = { alphaToTao: -1, taoToUsdt: -1 };

  const alphaResp = await fetchPrice(`${API_CONFIG.baseUrl}/dtao/pool/v1`);
  if (alphaResp && Array.isArray(alphaResp.data)) {
    prices.alphaToTao = alphaResp.data[0].price;
  }

  const taoResp = await fetchPrice(API_CONFIG.getTaoPriceUrl);
  if (taoResp && taoResp.price) {
    prices.taoToUsdt = taoResp.price;
  }

  return prices;
}

// ============================
// Widget Creation
// ============================

function createWelcomeWidget() {
  const widget = new ListWidget();
  widget.backgroundColor = ENV.colors.bg;

  const stack = widget.addStack();
  stack.layoutVertically();
  stack.centerAlignContent();

  addText(stack, 'ðŸ‘‹ Welcome to TAO Radar', 24, ENV.colors.gold, true);
  stack.addSpacer(10);
  addText(stack, 'Please configure the widget', 16, ENV.colors.gray);
  stack.addSpacer(5);
  addText(stack, 'with a settings ID', 14, ENV.colors.gray);
  stack.addSpacer(15);
  addText(stack, 'Example: setting_1', 12, ENV.colors.cyan_green);

  return widget;
}

function createErrorWidget(message) {
  const widget = new ListWidget();
  widget.backgroundColor = ENV.colors.bg;

  const stack = widget.addStack();
  stack.layoutVertically();
  stack.centerAlignContent();

  addText(stack, 'âš ï¸ Error', 20, ENV.colors.err, true);
  stack.addSpacer(10);
  
  const lines = message.split('\n');
  lines.forEach(line => {
    addText(stack, line, 12, ENV.colors.gray);
  });

  return widget;
}

function createWidget(neurons, prices, totals) {
  const widget = new ListWidget();
  widget.backgroundColor = ENV.colors.bg;

  const frame = widget.addStack();
  frame.spacing = ENV.part_spacing;
  frame.layoutVertically();

  if (config.widgetFamily === 'small') {
    drawTotalStack(frame, totals);
    drawPrices(frame, prices);
    drawFooterForSmall(frame, neurons);
  } else {
    const neuronsPanel = frame.addStack();
    const tableStacks = drawTableForLarge(neuronsPanel);
    drawNeuronsStatForLarge(neurons, tableStacks);
    drawTotalStackToTable(tableStacks, totals);

    const bottomPanel = frame.addStack();
    bottomPanel.layoutVertically();
    bottomPanel.addSpacer(5);
    drawPrices(bottomPanel, prices, true);
    drawTimeUpdated(bottomPanel);
  }

  widget.refreshAfterDate = new Date(Date.now() + ENV.refreshInterval);
  return widget;
}

function drawTotalStack(frame, totals) {
  const rowStack = frame.addStack();
  rowStack.layoutHorizontally();

  const colTotalStake = rowStack.addStack();
  colTotalStake.layoutVertically();
  addText(colTotalStake, 'âˆ‘ Stake', 18, ENV.colors.gray, true);
  addText(colTotalStake, `Î±${totals.stakeTotalAlphaToken.toFixed(2)}`, 14, ENV.colors.cyan_green_sim);
  addText(colTotalStake, `Ï„${totals.stakeTotalTao.toFixed(2)}`, 14, ENV.colors.orange_pearl);
  addText(colTotalStake, `$${totals.stakeTotalUSD.toFixed(2)}`, 14, ENV.colors.gold);

  rowStack.addSpacer();

  const colTotalDaily = rowStack.addStack();
  colTotalDaily.layoutVertically();
  addText(colTotalDaily, 'âˆ‘ Daily', 13, ENV.colors.gray, true);
  addText(colTotalDaily, `Î±${totals.dailyTotalAlphaToken.toFixed(2)}`, 11, ENV.colors.cyan_green_sim);
  addText(colTotalDaily, `Ï„${totals.dailyTotalTao.toFixed(2)}`, 11, ENV.colors.orange_pearl);
  addText(colTotalDaily, `$${totals.dailyTotalUSD.toFixed(2)}`, 11, ENV.colors.gold);
}

function drawTotalStackToTable(stacks, totals) {
  const [col0, col1, col2] = stacks;
  addText(col0, 'âˆ‘', 18, ENV.colors.cyan_green_sim, true);
  addText(col1, `Î±${totals.stakeTotalAlphaToken.toFixed(0)} | t${totals.stakeTotalTao.toFixed(2)} | $${totals.stakeTotalUSD.toFixed(2)}`, 14, ENV.colors.orange_pearl, true);
  addText(col2, `Î±${totals.dailyTotalAlphaToken.toFixed(0)} |t${totals.dailyTotalTao.toFixed(2)} | $${totals.dailyTotalUSD.toFixed(2)}`, 14, ENV.colors.gold, true);
}

function drawFooterForSmall(frame, neurons) {
  const bottomStack = frame.addStack();
  bottomStack.layoutVertically();

  const uidStack = bottomStack.addStack();
  uidStack.spacing = 3;
  uidStack.addSpacer();
  addText(uidStack, 'UIDs: ', 11, ENV.colors.gray, true);

  neurons.forEach(neuron => {
    const color = neuron.error ? ENV.colors.err : ENV.colors.cyan_green;
    addText(uidStack, `${neuron.uid}`, 11, color, true);
  });

  uidStack.addSpacer();
  drawTimeUpdated(bottomStack);
}

function drawTimeUpdated(stack) {
  const timeStack = stack.addStack();
  timeStack.addSpacer();
  addText(timeStack, 'Sync: ', 11, ENV.colors.gray);

  const date = timeStack.addDate(new Date());
  date.textColor = ENV.colors.gray;
  date.font = Font.systemFont(11);
  date.applyTimeStyle();
  timeStack.addSpacer();
}

function drawPrices(frame, prices, isLarge = false) {
  const rowStack = frame.addStack();
  rowStack.layoutHorizontally();
  const spacer = isLarge ? null : 5;

  const col1 = rowStack.addStack();
  col1.layoutVertically();
  addText(col1, '1Ï„ = ', 11, ENV.colors.orange_pearl, true);

  rowStack.addSpacer(spacer);

  const col2 = rowStack.addStack();
  col2.layoutVertically();
  addText(col2, `Î±${(1 / prices.alphaToTao).toFixed(2)}`, 11, ENV.colors.cyan_green_sim, true);

  rowStack.addSpacer(spacer);

  const col3 = rowStack.addStack();
  col3.layoutVertically();
  addText(col3, `$${parseFloat(prices.taoToUsdt).toFixed(2)}`, 11, ENV.colors.gold, true);
}

function drawTableForLarge(frame) {
  const createColumn = (title, color) => {
    const stack = frame.addStack();
    stack.spacing = ENV.spacing;
    stack.layoutVertically();
    addText(stack, title, 13, color, true);
    return stack;
  };

  const uidStack = createColumn('UIDs', ENV.colors.cyan_green);
  frame.addSpacer();
  const stakeStack = createColumn('Stake', ENV.colors.gold);
  frame.addSpacer();
  const dailyStack = createColumn('Daily', ENV.colors.white);

  return [uidStack, stakeStack, dailyStack];
}

function drawNeuronsStatForLarge(neurons, stacks) {
  const [uidStack, stakeStack, dailyStack] = stacks;

  neurons.forEach((neuron, i) => {
    const color = i % 2 === 0 ? ENV.colors.forEvenRow : ENV.colors.forNotEvenRow;

    if (!neuron.error) {
      addText(uidStack, `${neuron.uid}`, 12, color, true);
      addText(stakeStack, `Î±${neuron.stakeAlphaToken.toFixed(1)} | t${neuron.stakeTao.toFixed(2)} | $${neuron.stakeUSD.toFixed(0)}`, 12, color, true);
      addText(dailyStack, `Î±${neuron.dailyAlphaToken.toFixed(2)} | $${neuron.dailyUSD.toFixed(2)}`, 12, color, true);
    } else {
      addText(uidStack, `UID ${neuron.uid}: ${neuron.error}`, 12, ENV.colors.err, true);
      addText(stakeStack, '-', 12, ENV.colors.err, true);
      addText(dailyStack, '-', 12, ENV.colors.err, true);
    }
  });
}

function addText(frame, text, size, color, isSemibold = false) {
  const textElement = frame.addText(text);
  textElement.font = isSemibold ? Font.semiboldSystemFont(size) : Font.systemFont(size);
  textElement.textColor = color;
}
