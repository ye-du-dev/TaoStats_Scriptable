// ============================
// Configuration
// ============================

const SCRIPT_VERSION = '1.5'; // Version of the script
const CONFIG_URL = 'https://raw.githubusercontent.com/TAO-Radar/Scriptable-Widget/refs/heads/main/config.json';

const RAO = 10 ** -9;

const ENV = {
  colors: {
    bg: new Color('#0E0E0E'),
    err: new Color('#ad4904'),
    gold: new Color('#FDE047'),
    white: Color.white(),
    cyan_green: new Color('#00c2a6'),
    cyan_green_sim: new Color('#00c2b6'),
    orange_pearl: new Color('#e88148'),
    gray: Color.gray(),
    forEvenRow: new Color('#74b9ff'),
    forNotEvenRow: new Color('#a29bfe'),
  },
  spacing: 4,
  part_spacing: 7,
  refreshInterval: 300000,
};

// ============================
// Main Execution
// ============================

// Fetch API config dynamically
let API_CONFIG;
let remoteVersion = null;
let versionMismatch = false;
try {
  const configResult = await fetchApiConfig();
  API_CONFIG = {
    baseUrl: configResult.baseUrl,
    getTaoPriceUrl: configResult.getTaoPriceUrl
  };
  remoteVersion = configResult.version;
  versionMismatch = remoteVersion && remoteVersion !== SCRIPT_VERSION;
} catch (error) {
  console.error('Failed to fetch API config:', error);
  // Fallback to default config if remote fetch fails
  API_CONFIG = {
    baseUrl: 'https://widget.secondbuy.site/api',
    getTaoPriceUrl: 'https://api.binance.com/api/v3/ticker/price?symbol=TAOUSDT'
  };
}

if (config.runsInApp) {
  // Show welcome message in app
  const widget = createWelcomeWidget(versionMismatch, remoteVersion);
  config.widgetFamily = 'large';
  await widget.presentLarge();
  Script.complete();
} else {
  // Running as widget
  const settingsId = args.widgetParameter;
  
  if (!settingsId) {
    // No settings provided - show error
    const widget = createErrorWidget('No settings ID provided. Please configure the widget with a settings ID.');
    Script.setWidget(widget);
    Script.complete();
  } else {
    try {
      const settings = await fetchSettings(settingsId);
      const prices = await fetchPrices();
      const neurons = await fetchNeuronsByAddresses(settings, prices);
      neurons.sort((a, b) => parseInt(a.uid) - parseInt(b.uid));
      const totals = calculateTotals(neurons);
      const widget = createWidget(neurons, prices, totals, settings.currencies, versionMismatch);
      Script.setWidget(widget);
      Script.complete();
    } catch (error) {
      console.error(error);
      const errorWidget = createErrorWidget(`Error: ${error.message || 'Failed to load widget data'}`);
      Script.setWidget(errorWidget);
      Script.complete();
    }
  }
}

// ============================
// Data Fetching
// ============================

async function fetchApiConfig() {
  try {
    const request = new Request(CONFIG_URL);
    const response = await request.loadJSON();
    
    if (!response || !response.baseUrl || !response.getTaoPriceUrl) {
      throw new Error('Invalid config response');
    }
    
    return {
      baseUrl: response.baseUrl,
      getTaoPriceUrl: response.getTaoPriceUrl,
      version: response.version || null
    };
  } catch (error) {
    console.error('Error fetching API config:', error);
    throw error;
  }
}

async function fetchSettings(settingId) {
  try {
    const url = `${API_CONFIG.baseUrl}/settings/${settingId}`;
    const request = new Request(url);
    
    // Load response to check status code
    const httpResponse = await request.load();
    const statusCode = request.response.statusCode;
    
    if (statusCode === 404) {
      throw new Error('Settings not found');
    }
    
    if (statusCode !== 200) {
      throw new Error(`Failed to fetch settings (status: ${statusCode})`);
    }
    
    // Parse JSON from response data
    const response = JSON.parse(httpResponse.toRawString());
    
    if (!response || !response.addresses || !Array.isArray(response.addresses) || !response.netuid) {
      throw new Error('Invalid settings response');
    }
    
    return {
      addresses: response.addresses,
      netuid: response.netuid,
      currencies: response.currencies || ['USD'] // Default to USD if not provided
    };
  } catch (error) {
    console.error('Error fetching settings:', error);
    
    // Re-throw if it's already our custom error
    if (error.message === 'Settings not found') {
      throw error;
    }
    
    // Check error message for 404
    if (error.message && (error.message.includes('404') || error.message.includes('Not Found'))) {
      throw new Error('Settings not found');
    }
    
    throw error;
  }
}

async function fetchNeuronsByAddresses(settings, prices) {
  try {
    const allNeurons = await fetchAllNeurons(settings);
    
    if (allNeurons.length === 0) {
      return [{ uid: 0, error: 'No neurons found for the provided addresses.' }];
    }

    const { alphaToTao, taoToUsdt } = prices;

    return allNeurons.map(neuron => {
      const dailyAlphaToken = parseFloat(neuron.daily_reward) * RAO;
      const stakeAlphaToken = parseFloat(neuron.alpha_stake) * RAO;
      const dailyTao = dailyAlphaToken * alphaToTao;
      const stakeTao = stakeAlphaToken * alphaToTao;
      const dailyUSD = dailyTao * taoToUsdt;
      const stakeUSD = stakeTao * taoToUsdt;

      return {
        uid: neuron.uid,
        dailyAlphaToken,
        stakeAlphaToken,
        dailyTao,
        stakeTao,
        dailyUSD,
        stakeUSD
      };
    });
  } catch (error) {
    console.error('Failed to fetch neurons:', error);
    return [{ uid: 0, error: 'Failed to process neuron data.' }];
  }
}

function calculateTotals(neurons) {
  const initialTotals = {
    dailyTotalAlphaToken: 0,
    stakeTotalAlphaToken: 0,
    dailyTotalTao: 0,
    stakeTotalTao: 0,
    dailyTotalUSD: 0,
    stakeTotalUSD: 0
  };

  return neurons.reduce((acc, neuron) => {
    if (!neuron.error) {
      acc.dailyTotalAlphaToken += neuron.dailyAlphaToken;
      acc.stakeTotalAlphaToken += neuron.stakeAlphaToken;
      acc.dailyTotalTao += neuron.dailyTao;
      acc.stakeTotalTao += neuron.stakeTao;
      acc.dailyTotalUSD += neuron.dailyUSD;
      acc.stakeTotalUSD += neuron.stakeUSD;
    }
    return acc;
  }, initialTotals);
}

async function fetchAllNeurons(settings) {
  try {
    const allNeurons = [];
    const seenUids = new Set();

    // Fetch neurons for each address and combine results
    for (const address of settings.addresses) {
      try {
        const url = `${API_CONFIG.baseUrl}/metagraph/latest/v1?netuid=${settings.netuid}&search=${encodeURIComponent(address)}&page=1`;
        const response = await new Request(url).loadJSON();

        if (response && Array.isArray(response.data)) {
          // Add neurons that haven't been seen yet (deduplicate by UID)
          response.data.forEach(neuron => {
            if (!seenUids.has(neuron.uid)) {
              seenUids.add(neuron.uid);
              allNeurons.push(neuron);
            }
          });
        }
      } catch (error) {
        console.error(`Error fetching neurons for address ${address}:`, error);
      }
    }

    return allNeurons;
  } catch (error) {
    console.error('Error fetching neuron data:', error);
    return [];
  }
}

async function fetchPrice(url) {
  try {
    const response = await new Request(url).loadJSON();
    return response;
  } catch (error) {
    console.error(`Error fetching price from ${url}:`, error);
    return null;
  }
}

async function fetchPrices() {
  const prices = { 
    alphaToTao: -1, 
    taoToUsdt: -1,
    alphaSymbol: 'Î±', // Default fallback
    taoSymbol: 'Ï„'
  };

  const alphaResp = await fetchPrice(`${API_CONFIG.baseUrl}/dtao/pool/latest/v1`);
  if (alphaResp && Array.isArray(alphaResp.data) && alphaResp.data.length > 0) {
    prices.alphaToTao = alphaResp.data[0].price;
    if (alphaResp.data[0].symbol) {
      prices.alphaSymbol = alphaResp.data[0].symbol;
    }
  }

  const taoResp = await fetchPrice(API_CONFIG.getTaoPriceUrl);
  if (taoResp && taoResp.price) {
    prices.taoToUsdt = taoResp.price;
  }

  return prices;
}

// ============================
// Widget Creation
// ============================

function getCurrencyConfig() {
  return {
    ALPHA: { symbol: (prices) => prices.alphaSymbol, color: ENV.colors.cyan_green_sim },
    TAO: { symbol: (prices) => prices.taoSymbol, color: ENV.colors.orange_pearl },
    USD: { symbol: () => '$', color: ENV.colors.gold }
  };
}

function hasCurrency(currencies, currency) {
  return currencies.includes(currency);
}

function formatValue(value, symbol, decimals = 2) {
  return `${symbol}${value.toFixed(decimals)}`;
}

function formatValues(values, prices, currencies, config) {
  const parts = [];
  const currencyOrder = ['ALPHA', 'TAO', 'USD'];
  
  currencyOrder.forEach(currency => {
    if (hasCurrency(currencies, currency) && values[currency] !== undefined) {
      const cfg = getCurrencyConfig()[currency];
      const symbol = cfg.symbol(prices);
      const decimals = config.decimals[currency] || 2;
      parts.push(formatValue(values[currency], symbol, decimals));
    }
  });
  return parts.join(config.separator || ' | ');
}

function formatTotals(type, totals, prices, currencies, compact = false) {
  const config = {
    decimals: compact 
      ? { ALPHA: 0, TAO: 2, USD: 2 }
      : { ALPHA: 2, TAO: 2, USD: 2 },
    separator: compact && type === 'daily' ? ' |' : ' | '
  };

  const values = {
    ALPHA: type === 'stake' ? totals.stakeTotalAlphaToken : totals.dailyTotalAlphaToken,
    TAO: type === 'stake' ? totals.stakeTotalTao : totals.dailyTotalTao,
    USD: type === 'stake' ? totals.stakeTotalUSD : totals.dailyTotalUSD
  };

  return formatValues(values, prices, currencies, config);
}

function formatNeuronValues(type, neuron, prices, currencies) {
  const decimals = {
    stake: { ALPHA: 1, TAO: 2, USD: 0 },
    daily: { ALPHA: 2, USD: 2 }
  };

  const values = {
    stake: {
      ALPHA: neuron.stakeAlphaToken,
      TAO: neuron.stakeTao,
      USD: neuron.stakeUSD
    },
    daily: {
      ALPHA: neuron.dailyAlphaToken,
      USD: neuron.dailyUSD
    }
  };

  const valueConfig = values[type];
  const parts = [];
  const currencyOrder = ['ALPHA', 'TAO', 'USD'];
  
  currencyOrder.forEach(currency => {
    if (hasCurrency(currencies, currency) && valueConfig[currency] !== undefined) {
      const cfg = getCurrencyConfig()[currency];
      const symbol = cfg.symbol(prices);
      const decimal = decimals[type][currency] || 2;
      parts.push(formatValue(valueConfig[currency], symbol, decimal));
    }
  });

  return parts.join(' | ');
}

function createWelcomeWidget(showVersionWarning = false, remoteVersion = null) {
  const widget = new ListWidget();
  widget.backgroundColor = ENV.colors.bg;

  const stack = widget.addStack();
  stack.layoutVertically();
  stack.centerAlignContent();

  addText(stack, 'ðŸ‘‹ Welcome to TAO Radar', 24, ENV.colors.gold, true);
  
  if (showVersionWarning) {
    stack.addSpacer(10);
    addText(stack, 'âš ï¸ Update Available', 18, ENV.colors.err, true);
    addText(stack, `Remote version: ${remoteVersion}`, 14, ENV.colors.gray);
    addText(stack, `Your version: ${SCRIPT_VERSION}`, 14, ENV.colors.gray);
    addText(stack, 'Please update the script', 12, ENV.colors.cyan_green);
    stack.addSpacer(10);
  }
  
  stack.addSpacer(10);
  addText(stack, 'Please configure the widget', 16, ENV.colors.gray);
  stack.addSpacer(5);
  addText(stack, 'with a settings ID', 14, ENV.colors.gray);
  stack.addSpacer(15);
  addText(stack, 'Example: setting_1', 12, ENV.colors.cyan_green);
  stack.addSpacer(20);
  addText(stack, 'Made with â¤ï¸', 12, ENV.colors.gray);
  addText(stack, 'by Hand of Midas Validator', 12, ENV.colors.cyan_green);

  return widget;
}

function createErrorWidget(message) {
  const widget = new ListWidget();
  widget.backgroundColor = ENV.colors.bg;

  const stack = widget.addStack();
  stack.layoutVertically();
  stack.centerAlignContent();

  addText(stack, 'âš ï¸ Error', 20, ENV.colors.err, true);
  stack.addSpacer(10);
  
  const lines = message.split('\n');
  lines.forEach(line => {
    addText(stack, line, 12, ENV.colors.gray);
  });

  return widget;
}

function createWidget(neurons, prices, totals, currencies, showVersionWarning = false) {
  const widget = new ListWidget();
  widget.backgroundColor = ENV.colors.bg;

  const frame = widget.addStack();
  frame.spacing = ENV.part_spacing;
  frame.layoutVertically();

  if (config.widgetFamily === 'small') {
    drawTotalStack(frame, totals, prices, currencies);
    drawPrices(frame, prices, false, currencies);
    drawFooterForSmall(frame, neurons, showVersionWarning);
  } else {
    const neuronsPanel = frame.addStack();
    const tableStacks = drawTableForLarge(neuronsPanel);
    drawNeuronsStatForLarge(neurons, tableStacks, prices, currencies);
    drawTotalStackToTable(tableStacks, totals, prices, currencies);

    const bottomPanel = frame.addStack();
    bottomPanel.layoutVertically();
    bottomPanel.addSpacer(5);
    drawPrices(bottomPanel, prices, true, currencies);
    drawTimeUpdated(bottomPanel, showVersionWarning);
  }

  widget.refreshAfterDate = new Date(Date.now() + ENV.refreshInterval);
  return widget;
}

function drawTotalStack(frame, totals, prices, currencies) {
  const rowStack = frame.addStack();
  rowStack.layoutHorizontally();

  const drawColumn = (title, type, size, titleSize) => {
    const col = rowStack.addStack();
    col.layoutVertically();
    addText(col, title, titleSize, ENV.colors.gray, true);
    
    const currencyOrder = ['ALPHA', 'TAO', 'USD'];
    currencyOrder.forEach(currency => {
      if (hasCurrency(currencies, currency)) {
        const cfg = getCurrencyConfig()[currency];
        const values = {
          stake: { ALPHA: totals.stakeTotalAlphaToken, TAO: totals.stakeTotalTao, USD: totals.stakeTotalUSD },
          daily: { ALPHA: totals.dailyTotalAlphaToken, TAO: totals.dailyTotalTao, USD: totals.dailyTotalUSD }
        };
        const value = values[type][currency];
        const symbol = cfg.symbol(prices);
        addText(col, formatValue(value, symbol), size, cfg.color);
      }
    });

    return col;
  };

  drawColumn('âˆ‘ Stake', 'stake', 14, 18);
  rowStack.addSpacer();
  drawColumn('âˆ‘ Daily', 'daily', 11, 13);
}

function drawTotalStackToTable(stacks, totals, prices, currencies) {
  const [col0, col1, col2] = stacks;
  addText(col0, 'âˆ‘', 18, ENV.colors.cyan_green_sim, true);
  addText(col1, formatTotals('stake', totals, prices, currencies, true), 14, ENV.colors.orange_pearl, true);
  addText(col2, formatTotals('daily', totals, prices, currencies, true), 14, ENV.colors.gold, true);
}

function drawFooterForSmall(frame, neurons, showVersionWarning = false) {
  const bottomStack = frame.addStack();
  bottomStack.layoutVertically();

  const uidStack = bottomStack.addStack();
  uidStack.spacing = 3;
  uidStack.addSpacer();
  addText(uidStack, 'UIDs: ', 11, ENV.colors.gray, true);

  neurons.forEach(neuron => {
    const color = neuron.error ? ENV.colors.err : ENV.colors.cyan_green;
    addText(uidStack, `${neuron.uid}`, 11, color, true);
  });

  uidStack.addSpacer();
  drawTimeUpdated(bottomStack, showVersionWarning);
}

function drawTimeUpdated(stack, showVersionWarning = false) {
  const timeStack = stack.addStack();
  timeStack.addSpacer();
  
  if (showVersionWarning) {
    addText(timeStack, 'ðŸ”„ ', 11, ENV.colors.err);
  }
  
  addText(timeStack, 'Sync: ', 11, ENV.colors.gray);

  const date = timeStack.addDate(new Date());
  date.textColor = ENV.colors.gray;
  date.font = Font.systemFont(11);
  date.applyTimeStyle();
  timeStack.addSpacer();
}

function drawPrices(frame, prices, isLarge = false, currencies = ['USD']) {
  const rowStack = frame.addStack();
  rowStack.layoutHorizontally();
  const spacer = isLarge ? null : 5;

  if (hasCurrency(currencies, 'TAO')) {
    const col1 = rowStack.addStack();
    col1.layoutVertically();
    addText(col1, `1${prices.taoSymbol} = `, 11, ENV.colors.orange_pearl, true);
    rowStack.addSpacer(spacer);
  }

  if (hasCurrency(currencies, 'ALPHA')) {
    const col2 = rowStack.addStack();
    col2.layoutVertically();
    addText(col2, `${prices.alphaSymbol}${(1 / prices.alphaToTao).toFixed(2)}`, 11, ENV.colors.cyan_green_sim, true);
    rowStack.addSpacer(spacer);
  }

  if (hasCurrency(currencies, 'USD')) {
    const col3 = rowStack.addStack();
    col3.layoutVertically();
    addText(col3, `$${parseFloat(prices.taoToUsdt).toFixed(2)}`, 11, ENV.colors.gold, true);
  }
}

function drawTableForLarge(frame) {
  const createColumn = (title, color) => {
    const stack = frame.addStack();
    stack.spacing = ENV.spacing;
    stack.layoutVertically();
    addText(stack, title, 13, color, true);
    return stack;
  };

  const uidStack = createColumn('UIDs', ENV.colors.cyan_green);
  frame.addSpacer();
  const stakeStack = createColumn('Stake', ENV.colors.gold);
  frame.addSpacer();
  const dailyStack = createColumn('Daily', ENV.colors.white);

  return [uidStack, stakeStack, dailyStack];
}

function drawNeuronsStatForLarge(neurons, stacks, prices, currencies) {
  const [uidStack, stakeStack, dailyStack] = stacks;

  neurons.forEach((neuron, i) => {
    const color = i % 2 === 0 ? ENV.colors.forEvenRow : ENV.colors.forNotEvenRow;

    if (!neuron.error) {
      addText(uidStack, `${neuron.uid}`, 12, color, true);
      addText(stakeStack, formatNeuronValues('stake', neuron, prices, currencies), 12, color, true);
      addText(dailyStack, formatNeuronValues('daily', neuron, prices, currencies), 12, color, true);
    } else {
      addText(uidStack, `UID ${neuron.uid}: ${neuron.error}`, 12, ENV.colors.err, true);
      addText(stakeStack, '-', 12, ENV.colors.err, true);
      addText(dailyStack, '-', 12, ENV.colors.err, true);
    }
  });
}

function addText(frame, text, size, color, isSemibold = false) {
  const textElement = frame.addText(text);
  textElement.font = isSemibold ? Font.semiboldSystemFont(size) : Font.systemFont(size);
  textElement.textColor = color;
}
